# -*- coding: utf-8 -*-
"""dataset_personal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ke8IZdPIUzJbgjqpSngLdhhRa-6G4EB3

# Conjunto de datos para la entidad "Personal"
"""

# Uso del Pip install para poder importar la librería faker
!pip install faker

# Importar librería pandas para manejar y analizar datos
import pandas as pd
# Importar librería uuid para crear identificadores únicos.
import uuid
# Importar librería random para generar datos aleatorios.
import random
# Importar el paquete faker para generar datos fasos.
from faker import Faker
# Importar la librería datetime para manejar fechas.
import datetime
from datetime import date

# Delimitación del rango del número de elementos.
num_users = 5000

# Una lista de 7 características de la entidad personal
features = [
    "var_id_per",
    "var_genero_per",
    "var_nombre_per",
    "var_email_per",
    "dt_fecha_nac_per",
    "var_status_per",
    "var_id_dept"
]
# Creación de un DF para estas características
df = pd.DataFrame(columns=features)

# Generar un identificador para cada  miembro del personal
def idm_gen(n):
    """
    Función que se encarga de crear un id unico con nomenclatura básica
    ...
    
    Parametros
    ----------
    n : int
        representa el numero de indice correspondiente al registro
    
    Return
    ------
    "MSL--"+str(n+1) : str
        nomenclatura única de identificación del personal correspondiente
    """
    return "PRS "+str(n+1)

df['var_id_per'] = [idm_gen(i) for i in range(num_users)]

# Género del personal
genders = ["male", "female"]

df['var_genero_per'] = random.choices(
    genders, 
    weights=(45,55), 
    k=num_users
)
"""
Con la lista generada de las opciones de género, se proporciona la función de opciones
pesos para cada función y la cantidad de opciones hacer representadas por "k".
Por consiguiente, se asignó al atributo de "genero_per" del marco de datos.
"""

# Nombre del personal
# Creación de instancias de falsificador
faker = Faker()

def name_gen(gender):
    """
    Genera rápidamente un nombre basado en el género
    """
    if gender=='male':
        return faker.name_male()
    elif gender=='female':
        return faker.name_female()
    
    return faker.name()
    
# Generación de nombres para cada usuario
df['var_nombre_per'] = [name_gen(i) for i in df['var_genero_per']]

# Email del personal
def emailGen(name, duplicateFound=False):
    """
    Genera una dirección de correo electrónico aleatoria basada en el nombre de la persona. 
    Agrega un número al final si se encontró una dirección duplicada.
    """
    # Nombre de dominio falso para usar
    dom = "@nasa.dod.com"
    
    # Mayúsculas y minúsculas
    name = name.lower().split(" ")
    
    # Carácter aleatorio para insertar en el nombre
    chars = [".", "_"]
    
    new_name = name[0] + random.choice(chars) + name[1] 
    
    # Distinguir aún más el correo electrónico si se encontró un duplicado
    if duplicateFound:
        
        # Número aleatorio para insertar al final
        num = random.randint(0,100)
        
        # Insertar al final
        new_name = new_name + str(num)
        
    # Devolver la dirección de correo electrónico con el nombre de dominio adjunto
    return new_name + dom

emails = []

for name in df['var_nombre_per']:
    
    # Generación del correo electrónico
    email = emailGen(name)
    
    # Bucle hasta que se genere un correo electrónico único
    while email in emails:
        
        # Crear un correo electrónico con un número aleatorio
        email = emailGen(name, duplicateFound=True)
    
    # Adjuntar el nuevo correo electrónico a la lista
    emails.append(email)
    
df['var_email_per'] = emails

# Fecha de nacimiento del personal
def random_dob(start, end, n):
    """
    Generar una lista de un número determinado de marcas de tiempo
    """
    
    # El formato de marca de tiempo
    frmt = "%Y-%m-%d"
    
    # Dar formato a los dos períodos de tiempo
    stime = datetime.datetime.strptime(start, frmt)
    etime = datetime.datetime.strptime(end, frmt)
    
    # Creación del grupo para tiempos aleatorios
    td = etime - stime
    
    # Generar una lista con los tiempos aleatorios
    times = [(random.random() * td + stime).strftime(frmt) for _ in range(n)]
    
    return times

df['dt_fecha_nac_per'] = random_dob("1989-01-01", "1998-01-01", num_users)

# Fk "Id_depar"
def idm_gen(n):
    """
    Función que se encarga de crear un id unico con nomenclatura básica
    ...
    
    Parametros
    ----------
    n : int
        representa el numero de indice correspondiente al registro
    
    Return
    ------
    "MSL--"+str(n+1) : str
        nomenclatura única de identificación del departamento correspondiente
    """
    return "DPTO "+str(n+1)

df['var_id_dept'] = [idm_gen(i) for i in range(num_users)]

# Estado del departamento
Status_per = ["Activo", "Inactivo"]

df['var_status_per']= random.choices(
    Status_per, 
    weights=(45,55), 
    k=num_users
)
"""
Con la lista generada de las opciones de estados, se proporciona la
función de opciones pesos para cada función y la cantidad de opciones hacer representadas
por "k". Por consiguiente, se asignó al atributo de "var_status_dept" del marco de datos.
"""

# Guardar el conjunto de datos
df.to_csv('dataset_users.csv')

# Mostrar el conjunto de datos
pd.read_csv('dataset_users.csv', index_col=0)