# -*- coding: utf-8 -*-
"""dataset_Permisos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1v0IIK52io-lh0rypySVhBuiIiGCra7eO
"""

# Uso del Pip install para poder importar la librería faker
!pip install faker

# Importar librería pandas para manejar y analizar datos
import pandas as pd
# Importar librería uuid para crear identificadores únicos.
import uuid
# Importar librería random para generar datos aleatorios.
import random
# Importar el paquete faker para generar datos fasos.
from faker import Faker
# Importar la librería datetime para manejar fechas.
import datetime
from datetime import date

# Delimitación del rango del número de elementos.
num_permiso = 5000

#Instanciación faker
faker = Faker()

# Una lista de 6 características para la entidad permiso
atributos = [
    "var_id_perm",
    "var_entidad_perm",
    "var_tipo_perm",
    "dt_fecha_asigna_perm",
    "dt_fecha_caduca_perm", 
    "var_status_perm" 
]

# arreglo con valores para atributo entidad
entidad =[
    "Permisos",
    "Roles",
    "Personal",
    "Departamento",
    "Misil",
    "Componente",
    "Pieza",
    "Proveedor",
    "Parametro"
]

# arreglo con valores para atributo tipo
tipo = [
    "Lectura",
    "Escritura"
]

# arreglo con valores para atributo estado
status = [
    "Vigente",
    "Caducado"
]

# Creación de un DF para las 6 características de la entidad permiso
df = pd.DataFrame(columns = atributos)

# Generar un identificador por cada permiso
def idp_gen(n):
    """
    Función para crear la id única
    ...
    Parametro
    n : int
        corresponde al numero indicador del registro correspondiente 
    
    Return
    ------
    "PERM-"+str(n+1) : str
        se crea las identificaciones únicas para los permisos
    """
    return "PERM "+str(n+1)

df['var_id_perm'] = [idp_gen(i) for i in range(num_permiso)]

# Determinar la entidad a la que pertenece cada permiso
def entidad_gen():
    """
    Función para asignar una entidad para el permiso
    ...
    
    Return
    ------
    random.choice(entidad) : str
        generación de la entidad para su asignación en el registro
    """
    return random.choice(entidad)

df['var_entidad_perm'] = [entidad_gen() for i in range(num_permiso)]

# Determinar el tipo de permiso 
def tipo_gen():
    """
    Función para asignar el tipo de permiso
    ...
    
    Return
    ------
    random.choice(tipo) : str
        generación del tipo de permiso aleatorio
    """
    return random.choice(tipo)

df['var_tipo_perm'] = [tipo_gen() for i in range(num_permiso)]

# Generar una fecha de asignación de permiso a cada registro
def fechAsig_gen():
    """
    Función para crear fecha de asignación del permiso
    ...
    
    Return
    ------
    faker.date_between('-5y') : obj datetime.date
        generación de una fecha entre 10 años antes hasta la fecha actual
    """
    return faker.date_between('-5y')

df['dt_fecha_asigna_perm'] = [fechAsig_gen() for i in range(num_permiso)]

# Determinar una fecha de caducidad de permiso de cada registro
def fechCad_gen(fecha):
    """
    Función para crear fecha de caducidad
    ...
    
    Parametro
    ---------
    fecha : obj Datetime.date
        variable que corresponde a la fecha de asignación del permiso
    
    Return
    ------
    caduca: str
        generación de una fecha con rango de 10 años antes y despues dela fecha actual
    """
    #asignación de objeto con fecha con rango de 10 años antes y despues de fecha actual
    caduca = faker.date_this_decade(True, True)
    #bucle para asegurar que la fecha inicio sea menor a la fecha caduca
    while (caduca <= fecha):
        caduca = faker.date_this_decade(True, True) #genera nueva fecha que cumpla con condicional
    return caduca

df['dt_fecha_caduca_perm'] = [fechCad_gen(i) for i in df["dt_fecha_asigna_perm"]]

# Determinar el estado en que se encuentra cada permiso
def status_gen(fecha):
    """
    Función para la generación de estado del permiso
    ...
    
    Parametros
    ----------
    fecha : obj datetime.date
        fecha correspondiente a la caducidad
    
    Return
    ------
    status[0] :  str
        envía la cadena correspondiente al indice 0 del arreglo status
        
    status[1] : str
        envia la cadena que está en el indice 1 del arreglo status
    """
    #formato de fecha
    frmt = "%Y-%m-%d"
    #Asignación de fecha actual en tipo objeto date
    now = date.today()
    #Fecha actual conseguida
    stime = datetime.datetime.strptime(str(fecha), frmt)
    #Fecha actual
    now1 = datetime.datetime.strptime(str(now), frmt)
    #indicador entero basado en el calculo de edad
    ind = int((stime-now1).days/365.25)
    #asignación de estado de acuerdo al indicador
    if (ind>0):
        return status[0]
    else:
        return status[1]

df['var_status_perm'] = [status_gen(i) for i in df["dt_fecha_caduca_perm"]]

# Guardar el conjunto de datos
df.to_csv('dataset_Permisos.csv')

# Mostrar el conjunto de datos
pd.read_csv('dataset_Permisos.csv', index_col=0)